// automatically generated by the FlatBuffers compiler, do not modify

include "flatbuffers.lobster"

namespace ppx

enum + 
    MessageBody_NONE = 0,
    MessageBody_Handshake = 1,
    MessageBody_HandshakeResult = 2,
    MessageBody_Run = 3,
    MessageBody_RunResult = 4,
    MessageBody_Sample = 5,
    MessageBody_SampleResult = 6,
    MessageBody_Observe = 7,
    MessageBody_ObserveResult = 8,
    MessageBody_Tag = 9,
    MessageBody_TagResult = 10,
    MessageBody_Reset = 11

enum + 
    Distribution_NONE = 0,
    Distribution_Normal = 1,
    Distribution_Uniform = 2,
    Distribution_Categorical = 3,
    Distribution_Poisson = 4

struct Message

struct Tensor

struct Handshake

struct HandshakeResult

struct Run

struct RunResult

struct Sample

struct SampleResult

struct Observe

struct ObserveResult

struct Tag

struct TagResult

struct Reset

struct Normal

struct Uniform

struct Categorical

struct Poisson

struct Beta

struct Gamma

struct LogNormal

struct Exponential

struct Weibull

struct Message : flatbuffers_handle
    def body_type():
        buf_.flatbuffers_field_int8(pos_, 4, 0)
    def body_as_Handshake():
        ppx_Handshake { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_HandshakeResult():
        ppx_HandshakeResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Run():
        ppx_Run { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_RunResult():
        ppx_RunResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Sample():
        ppx_Sample { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_SampleResult():
        ppx_SampleResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Observe():
        ppx_Observe { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_ObserveResult():
        ppx_ObserveResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Tag():
        ppx_Tag { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_TagResult():
        ppx_TagResult { buf_, buf_.flatbuffers_field_table(pos_, 6) }
    def body_as_Reset():
        ppx_Reset { buf_, buf_.flatbuffers_field_table(pos_, 6) }

def GetRootAsMessage(buf:string): Message { buf, buf.flatbuffers_indirect(0) }

def MessageStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def MessageAddBodyType(b_:flatbuffers_builder, body_type:int):
    b_.PrependUint8Slot(0, body_type, 0)
def MessageAddBody(b_:flatbuffers_builder, body:int):
    b_.PrependUOffsetTRelativeSlot(1, body, 0)
def MessageEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Tensor : flatbuffers_handle
    def data(i:int):
        buf_.read_float64_le(buf_.flatbuffers_field_vector(pos_, 4) + i * 8)
    def data_length():
        buf_.flatbuffers_field_vector_len(pos_, 4)
    def shape(i:int):
        buf_.read_int32_le(buf_.flatbuffers_field_vector(pos_, 6) + i * 4)
    def shape_length():
        buf_.flatbuffers_field_vector_len(pos_, 6)

def GetRootAsTensor(buf:string): Tensor { buf, buf.flatbuffers_indirect(0) }

def TensorStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def TensorAddData(b_:flatbuffers_builder, data:int):
    b_.PrependUOffsetTRelativeSlot(0, data, 0)
def TensorStartDataVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(8, n_, 8)
def TensorCreateDataVector(b_:flatbuffers_builder, v_:[float]):
    b_.StartVector(8, v_.length, 8)
    reverse(v_) e_: b_.PrependFloat64(e_)
    b_.EndVector(v_.length)
def TensorAddShape(b_:flatbuffers_builder, shape:int):
    b_.PrependUOffsetTRelativeSlot(1, shape, 0)
def TensorStartShapeVector(b_:flatbuffers_builder, n_:int):
    b_.StartVector(4, n_, 4)
def TensorCreateShapeVector(b_:flatbuffers_builder, v_:[int]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependInt32(e_)
    b_.EndVector(v_.length)
def TensorEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Handshake : flatbuffers_handle
    def system_name():
        buf_.flatbuffers_field_string(pos_, 4)

def GetRootAsHandshake(buf:string): Handshake { buf, buf.flatbuffers_indirect(0) }

def HandshakeStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def HandshakeAddSystemName(b_:flatbuffers_builder, system_name:int):
    b_.PrependUOffsetTRelativeSlot(0, system_name, 0)
def HandshakeEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct HandshakeResult : flatbuffers_handle
    def system_name():
        buf_.flatbuffers_field_string(pos_, 4)
    def model_name():
        buf_.flatbuffers_field_string(pos_, 6)

def GetRootAsHandshakeResult(buf:string): HandshakeResult { buf, buf.flatbuffers_indirect(0) }

def HandshakeResultStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def HandshakeResultAddSystemName(b_:flatbuffers_builder, system_name:int):
    b_.PrependUOffsetTRelativeSlot(0, system_name, 0)
def HandshakeResultAddModelName(b_:flatbuffers_builder, model_name:int):
    b_.PrependUOffsetTRelativeSlot(1, model_name, 0)
def HandshakeResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Run : flatbuffers_handle

def GetRootAsRun(buf:string): Run { buf, buf.flatbuffers_indirect(0) }

def RunStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def RunEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct RunResult : flatbuffers_handle
    def result():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsRunResult(buf:string): RunResult { buf, buf.flatbuffers_indirect(0) }

def RunResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def RunResultAddResult(b_:flatbuffers_builder, result:int):
    b_.PrependUOffsetTRelativeSlot(0, result, 0)
def RunResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Sample : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        buf_.flatbuffers_field_int8(pos_, 8, 0)
    def distribution_as_Normal():
        ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def control():
        buf_.flatbuffers_field_int8(pos_, 12, 1)
    def replace():
        buf_.flatbuffers_field_int8(pos_, 14, 0)

def GetRootAsSample(buf:string): Sample { buf, buf.flatbuffers_indirect(0) }

def SampleStart(b_:flatbuffers_builder):
    b_.StartObject(6)
def SampleAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def SampleAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def SampleAddDistributionType(b_:flatbuffers_builder, distribution_type:int):
    b_.PrependUint8Slot(2, distribution_type, 0)
def SampleAddDistribution(b_:flatbuffers_builder, distribution:int):
    b_.PrependUOffsetTRelativeSlot(3, distribution, 0)
def SampleAddControl(b_:flatbuffers_builder, control:int):
    b_.PrependBoolSlot(4, control, 1)
def SampleAddReplace(b_:flatbuffers_builder, replace:int):
    b_.PrependBoolSlot(5, replace, 0)
def SampleEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct SampleResult : flatbuffers_handle
    def result():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsSampleResult(buf:string): SampleResult { buf, buf.flatbuffers_indirect(0) }

def SampleResultStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def SampleResultAddResult(b_:flatbuffers_builder, result:int):
    b_.PrependUOffsetTRelativeSlot(0, result, 0)
def SampleResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Observe : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def distribution_type():
        buf_.flatbuffers_field_int8(pos_, 8, 0)
    def distribution_as_Normal():
        ppx_Normal { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Uniform():
        ppx_Uniform { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Categorical():
        ppx_Categorical { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def distribution_as_Poisson():
        ppx_Poisson { buf_, buf_.flatbuffers_field_table(pos_, 10) }
    def value_():
        o := buf_.flatbuffers_field_table(pos_, 12)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsObserve(buf:string): Observe { buf, buf.flatbuffers_indirect(0) }

def ObserveStart(b_:flatbuffers_builder):
    b_.StartObject(5)
def ObserveAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def ObserveAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def ObserveAddDistributionType(b_:flatbuffers_builder, distribution_type:int):
    b_.PrependUint8Slot(2, distribution_type, 0)
def ObserveAddDistribution(b_:flatbuffers_builder, distribution:int):
    b_.PrependUOffsetTRelativeSlot(3, distribution, 0)
def ObserveAddValue_(b_:flatbuffers_builder, value_:int):
    b_.PrependUOffsetTRelativeSlot(4, value_, 0)
def ObserveEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct ObserveResult : flatbuffers_handle

def GetRootAsObserveResult(buf:string): ObserveResult { buf, buf.flatbuffers_indirect(0) }

def ObserveResultStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def ObserveResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Tag : flatbuffers_handle
    def address():
        buf_.flatbuffers_field_string(pos_, 4)
    def name():
        buf_.flatbuffers_field_string(pos_, 6)
    def value_():
        o := buf_.flatbuffers_field_table(pos_, 8)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsTag(buf:string): Tag { buf, buf.flatbuffers_indirect(0) }

def TagStart(b_:flatbuffers_builder):
    b_.StartObject(3)
def TagAddAddress(b_:flatbuffers_builder, address:int):
    b_.PrependUOffsetTRelativeSlot(0, address, 0)
def TagAddName(b_:flatbuffers_builder, name:int):
    b_.PrependUOffsetTRelativeSlot(1, name, 0)
def TagAddValue_(b_:flatbuffers_builder, value_:int):
    b_.PrependUOffsetTRelativeSlot(2, value_, 0)
def TagEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct TagResult : flatbuffers_handle

def GetRootAsTagResult(buf:string): TagResult { buf, buf.flatbuffers_indirect(0) }

def TagResultStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def TagResultEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Reset : flatbuffers_handle

def GetRootAsReset(buf:string): Reset { buf, buf.flatbuffers_indirect(0) }

def ResetStart(b_:flatbuffers_builder):
    b_.StartObject(0)
def ResetEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Normal : flatbuffers_handle
    def mean():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def stddev():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsNormal(buf:string): Normal { buf, buf.flatbuffers_indirect(0) }

def NormalStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def NormalAddMean(b_:flatbuffers_builder, mean:int):
    b_.PrependUOffsetTRelativeSlot(0, mean, 0)
def NormalAddStddev(b_:flatbuffers_builder, stddev:int):
    b_.PrependUOffsetTRelativeSlot(1, stddev, 0)
def NormalEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Uniform : flatbuffers_handle
    def low():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def high():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsUniform(buf:string): Uniform { buf, buf.flatbuffers_indirect(0) }

def UniformStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def UniformAddLow(b_:flatbuffers_builder, low:int):
    b_.PrependUOffsetTRelativeSlot(0, low, 0)
def UniformAddHigh(b_:flatbuffers_builder, high:int):
    b_.PrependUOffsetTRelativeSlot(1, high, 0)
def UniformEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Categorical : flatbuffers_handle
    def probs():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsCategorical(buf:string): Categorical { buf, buf.flatbuffers_indirect(0) }

def CategoricalStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def CategoricalAddProbs(b_:flatbuffers_builder, probs:int):
    b_.PrependUOffsetTRelativeSlot(0, probs, 0)
def CategoricalEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Poisson : flatbuffers_handle
    def rate():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsPoisson(buf:string): Poisson { buf, buf.flatbuffers_indirect(0) }

def PoissonStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def PoissonAddRate(b_:flatbuffers_builder, rate:int):
    b_.PrependUOffsetTRelativeSlot(0, rate, 0)
def PoissonEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Beta : flatbuffers_handle
    def concentration0():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def concentration1():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsBeta(buf:string): Beta { buf, buf.flatbuffers_indirect(0) }

def BetaStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def BetaAddConcentration0(b_:flatbuffers_builder, concentration0:int):
    b_.PrependUOffsetTRelativeSlot(0, concentration0, 0)
def BetaAddConcentration1(b_:flatbuffers_builder, concentration1:int):
    b_.PrependUOffsetTRelativeSlot(1, concentration1, 0)
def BetaEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Gamma : flatbuffers_handle
    def concentration():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def rate():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsGamma(buf:string): Gamma { buf, buf.flatbuffers_indirect(0) }

def GammaStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def GammaAddConcentration(b_:flatbuffers_builder, concentration:int):
    b_.PrependUOffsetTRelativeSlot(0, concentration, 0)
def GammaAddRate(b_:flatbuffers_builder, rate:int):
    b_.PrependUOffsetTRelativeSlot(1, rate, 0)
def GammaEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct LogNormal : flatbuffers_handle
    def mean():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def stddev():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsLogNormal(buf:string): LogNormal { buf, buf.flatbuffers_indirect(0) }

def LogNormalStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def LogNormalAddMean(b_:flatbuffers_builder, mean:int):
    b_.PrependUOffsetTRelativeSlot(0, mean, 0)
def LogNormalAddStddev(b_:flatbuffers_builder, stddev:int):
    b_.PrependUOffsetTRelativeSlot(1, stddev, 0)
def LogNormalEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Exponential : flatbuffers_handle
    def rate():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsExponential(buf:string): Exponential { buf, buf.flatbuffers_indirect(0) }

def ExponentialStart(b_:flatbuffers_builder):
    b_.StartObject(1)
def ExponentialAddRate(b_:flatbuffers_builder, rate:int):
    b_.PrependUOffsetTRelativeSlot(0, rate, 0)
def ExponentialEnd(b_:flatbuffers_builder):
    b_.EndObject()

struct Weibull : flatbuffers_handle
    def scale():
        o := buf_.flatbuffers_field_table(pos_, 4)
        if o: ppx_Tensor { buf_, o } else: nil
    def concetration():
        o := buf_.flatbuffers_field_table(pos_, 6)
        if o: ppx_Tensor { buf_, o } else: nil

def GetRootAsWeibull(buf:string): Weibull { buf, buf.flatbuffers_indirect(0) }

def WeibullStart(b_:flatbuffers_builder):
    b_.StartObject(2)
def WeibullAddScale(b_:flatbuffers_builder, scale:int):
    b_.PrependUOffsetTRelativeSlot(0, scale, 0)
def WeibullAddConcetration(b_:flatbuffers_builder, concetration:int):
    b_.PrependUOffsetTRelativeSlot(1, concetration, 0)
def WeibullEnd(b_:flatbuffers_builder):
    b_.EndObject()

